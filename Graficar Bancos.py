import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from shapely.geometry import Point


def generate_rectangular_pattern(burden, spacing, azimuth_degrees, num_rows, num_cols):
    """
    Generates 2D (X, Y) coordinates for a rectangular drilling pattern
    and stores them in a Pandas DataFrame.

    Args:
        burden (float): Distance between rows (meters).
        spacing (float): Distance between holes in a row (meters).
        azimuth_degrees (float): Orientation angle of the pattern in degrees.
                                 Measured clockwise from North (positive Y-axis).
                                 An azimuth of 0 degrees means rows are parallel to the X-axis (East-West).
                                 An azimuth of 90 degrees means rows are parallel to the Y-axis (North-South).
        num_rows (int): Number of rows of holes (in the burden direction).
        num_cols (int): Number of columns of holes (in the spacing direction).

    Returns:
        pandas.DataFrame: DataFrame with columns 'Hole_ID', 'Row', 'Col', 'Coord_X', 'Coord_Y'.
    """
    # --- Calculate rotation angle for np.cos/sin ---
    # np.cos/sin expect angle counter-clockwise from positive X (East).
    # Azimuth is clockwise from positive Y (North).
    # Angle from +X counter-clockwise = 90 degrees - Azimuth clockwise from +Y
    rotation_radians_from_east = np.radians(90 - azimuth_degrees)

    # --- Generate base coordinates without rotation ---
    # We consider the first perforación (en la primera fila y columna) en el origen (0,0).
    # Las filas se extienden en la dirección 'Burden' y las columnas en la dirección 'Espaciamiento'.
    # En la malla base no rotada, asumimos que el Espaciamiento es a lo largo del eje X
    # y el Burden a lo largo del eje Y.

    base_coordinates = []

    for i in range(num_rows): # i = row index (0 to num_rows-1)
        for j in range(num_cols): # j = column index (0 to num_cols-1)
            # Coordinates in the base grid (non-rotated)
            # X increases with spacing (columns), Y increases with burden (rows)
            base_x = j * spacing
            base_y = i * burden

            base_coordinates.append({
                'Row': i,
                'Col': j,
                'Base_X': base_x,
                'Base_Y': base_y
            })

    df_base = pd.DataFrame(base_coordinates)

    # --- Apply rotation to each point ---
    # Rotation is applied around the origin (0,0).
    # If you wanted to rotate around the center of the pattern,
    # you would need to translate the points so the center is at (0,0),
    # rotate, and then translate them back. For this simple top-down view,
    # rotating around the origin where the base grid starts is sufficient.

    cos_theta = np.cos(rotation_radians_from_east)
    sin_theta = np.sin(rotation_radians_from_east)

    # Apply the rotation formula to each point
    # X_rotated = X_base * cos(theta) - Y_base * sin(theta)
    # Y_rotated = X_base * sin(theta) + Y_base * cos(theta)
    df_base['Coord_X'] = df_base['Base_X'] * cos_theta - df_base['Base_Y'] * sin_theta
    df_base['Coord_Y'] = df_base['Base_X'] * sin_theta + df_base['Base_Y'] * cos_theta

    # Assign Hole IDs and select/reorder final columns
    df_coords = df_base[['Row', 'Col', 'Coord_X', 'Coord_Y']].copy()
    df_coords['Hole_ID'] = [f'P-{i+1:03d}' for i in df_coords.index] # Assign sequential ID like P-001, P-002...
    df_coords = df_coords[['Hole_ID', 'Row', 'Col', 'Coord_X', 'Coord_Y']] # Reorder columns


    return df_coords


def visualize_pattern(df_coords, burden, spacing, azimuth_degrees):
    """
    Generates a top-down view plot of the drilling pattern and labels holes,
    including a line for the free face.

    Args:
        df_coords (pandas.DataFrame): DataFrame generated by generate_rectangular_pattern.
        burden (float): Distance between rows (used for plotting the free face).
        spacing (float): Distance between holes (used for title).
        azimuth_degrees (float): Azimuth angle (used for plotting the free face and title).
    """
    plt.figure(figsize=(10, 8)) # Figure size

    # Plot the points (holes)
    # s is marker size
    plt.scatter(df_coords['Coord_X'], df_coords['Coord_Y'], marker='o', color='blue', s=50, label='Pozos')

    # --- Add labels for each hole ---
    # Iterate through the DataFrame and add text label for each point
    for index, row in df_coords.iterrows():
        plt.text(
            row['Coord_X'],
            row['Coord_Y'],
            row['Hole_ID'], # The text to display
            fontsize=8,      # Font size
            ha='left',       # Horizontal alignment ('left', 'center', 'right')
            va='bottom'      # Vertical alignment ('top', 'center', 'bottom')
            # xytext=(5, 5),   # Optional: Offset text position (pixels)
            # textcoords='offset points'
        )

    # --- Add Free Face Line ---
    # Recalculate rotation angle (counter-clockwise from positive X)
    rotation_radians_from_east = np.radians(90 - azimuth_degrees)
    cos_theta = np.cos(rotation_radians_from_east)
    sin_theta = np.sin(rotation_radians_from_east)

    # The free face is one burden distance away from the first row (Row 0)
    # The vector from the first row towards the face, with length = burden, is:
    # In the base grid (Spacing=X, Burden=Y), the direction opposite to burden is (0, -1)
    # After rotating (0, -1) by theta (CCW from +X):
    # Rotated X = 0 * cos(theta) - (-1) * sin(theta) = sin(theta)
    # Rotated Y = 0 * sin(theta) + (-1) * cos(theta) = -cos(theta)
    # So the vector to shift points from the first row to the face is (burden * sin(theta), -burden * cos(theta))

    vector_to_face_x = burden * sin_theta
    vector_to_face_y = -burden * cos_theta

    # Get coordinates of the first and last hole in the first row (Row 0)
    first_hole_row0 = df_coords[df_coords['Row'] == 0].iloc[0]
    last_hole_row0 = df_coords[df_coords['Row'] == 0].iloc[-1]

    # Calculate the coordinates of the endpoints of the free face line
    # Shift the first and last hole of the first row by the vector_to_face
    free_face_point1_x = first_hole_row0['Coord_X'] + vector_to_face_x
    free_face_point1_y = first_hole_row0['Coord_Y'] + vector_to_face_y

    free_face_point2_x = last_hole_row0['Coord_X'] + vector_to_face_x
    free_face_point2_y = last_hole_row0['Coord_Y'] + vector_to_face_y

    # Plot the free face line
    plt.plot(
        [free_face_point1_x, free_face_point2_x],
        [free_face_point1_y, free_face_point2_y],
        color='red',
        linestyle='--', # Dashed line
        linewidth=2,    # Line thickness
        label='Cara libre' # Label for legend
    )
    # --- End Free Face Line ---


    # Improve visualization
    plt.title(f'Vista en planta\nBurden={burden}m, Espaciamiento={spacing}m, Azimuth={azimuth_degrees}° (Desde el norte, horario)')
    plt.xlabel('Coordenada este (m)')
    plt.ylabel('Coordenada norte (m)')
    plt.grid(True)          # Show grid
    plt.axis('equal')       # Ensure equal scaling on both axes
    plt.axhline(0, color='grey', lw=0.5, linestyle='--') # X-axis (East-West)
    plt.axvline(0, color='grey', lw=0.5, linestyle='--') # Y-axis (North-South)
    # Optional: Add labels for North, South, East, West axes if desired
    # plt.text(plt.xlim()[1]*0.9, 0, 'East', ha='center', va='bottom')
    # plt.text(plt.xlim()[0]*0.9, 0, 'West', ha='center', va='bottom')
    # plt.text(0, plt.ylim()[1]*0.9, 'North', ha='left', va='center')
    # plt.text(0, plt.ylim()[0]*0.9, 'South', ha='left', va='center')

    # Add legend to show labels for Holes and Free Face
    plt.legend()
    plt.show()


# --- Example Usage with User Input ---
if __name__ == "__main__":
    print("--- Generando patrón de perforación ---")

    # Get inputs from the user
    try:
        burden_input = float(input("Ingrese Burden (en metros): "))
        spacing_input = float(input("Ingrese espaciamiento (en metros): "))
        azimuth_input = float(input("Ingrese Azimuth (en grados, 0=Norte, horario): "))
        num_rows_input = int(input("Ingrese numero de filas: "))
        num_cols_input = int(input("Ingrese numero de columnas: "))

    except ValueError:
        print("Input invalido. Ingrese un valor factible.")
        exit() # Exit the script if input is invalid

    print(f"\nGenerating pattern with Burden={burden_input}m, Spacing={spacing_input}m, Azimuth={azimuth_input}°")
    print(f"Pattern of {num_rows_input} rows x {num_cols_input} columns.")

    # Generate the pattern coordinates
    df_pattern_coords = generate_rectangular_pattern(
        burden_input,
        spacing_input,
        azimuth_input,
        num_rows_input,
        num_cols_input
    )

    # Display the generated coordinates
    print("\nHole Coordinates (2D Plane):")
    print(df_pattern_coords)

    # Visualizar la malla en planta con etiquetas y cara libre
    visualize_pattern(
        df_pattern_coords,
        burden_input,
        spacing_input,
        azimuth_input
    )

    print("\nProceso Completado.")